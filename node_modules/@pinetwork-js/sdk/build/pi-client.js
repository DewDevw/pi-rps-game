"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PiClient = exports.versions = void 0;
const api_typing_1 = require("@pinetwork-js/api-typing");
const handlers_1 = require("./handlers");
const message_types_1 = require("./message-types");
const util_1 = require("./util");
const get_mutation_observer_1 = require("./util/get-mutation-observer");
/**
 * Available SDK versions
 */
exports.versions = ['2.0'];
/**
 * Available Pi Platform API scopes
 */
const availableScopes = new Set([
    'payments',
    'username',
    'roles',
    'platform',
    'wallet_address',
    'preferred_language',
]);
/**
 * The MutationObserver used to track the location of the user
 */
let locationTracker;
/**
 * Main class of the SDK
 */
class PiClient {
    /**
     * Whether the SDK is ready to be used or not
     */
    initialized = false;
    /**
     * The request handler for API requests
     */
    api = handlers_1.RequestHandler.getInstance();
    /**
     * The list of scopes consented by the user
     */
    consentedScopes = [];
    /**
     * Callback function triggered if an incomplete payment is found during the process of
     * authentication or payment creation
     */
    onIncompletePaymentFound;
    /**
     * Initialize the SDK
     *
     * @param options - Options to initialize the SDK
     */
    async init(options) {
        if (!exports.versions.includes(options.version)) {
            throw new Error('Unrecognized version number');
        }
        if (options.sandbox) {
            handlers_1.MessageHandler.setSandboxMode(true);
        }
        if (this.getPiHostApp() === 'pi-net') {
            locationTracker ??= (0, get_mutation_observer_1.getLocationTracker)();
            locationTracker.observe(document.body, { childList: true, subtree: true });
        }
        this.initTracking();
        this.initialized = true;
    }
    /**
     * Authenticate the user
     *
     * @param scopes - The list of requested scopes
     * @param onIncompletePaymentFound - Callback function triggered if an incomplete payment is found
     * @returns information about the authenticated user
     */
    async authenticate(scopes, onIncompletePaymentFound) {
        this.checkInitialized();
        if (!scopes.every((scope) => availableScopes.has(scope))) {
            throw new Error("Invalid scopes found. Please check the scopes you're requesting again.");
        }
        const scopeConsentResult = await handlers_1.MessageHandler.sendSDKMessage({
            type: message_types_1.MessageType.OPEN_CONSENT_MODAL,
            payload: {
                scopes,
            },
        });
        if (!scopeConsentResult || scopeConsentResult.payload.cancelled) {
            throw new Error('User consent cancelled.');
        }
        if (scopeConsentResult.payload.pinet_unsupported) {
            throw new Error('Method unsupported in PiNet.');
        }
        const applicationInformationMessage = await handlers_1.MessageHandler.sendSDKMessage({
            type: message_types_1.MessageType.COMMUNICATION_INFORMATION_REQUEST,
        });
        if (!applicationInformationMessage) {
            throw new Error('Authentication failed.');
        }
        const applicationInformation = applicationInformationMessage.payload;
        this.api.init(applicationInformation);
        this.onIncompletePaymentFound = onIncompletePaymentFound;
        const user = await this.api.get(api_typing_1.getAuthenticatedUser);
        if (!user || !this.api.accessToken) {
            throw new Error('Authentication failed.');
        }
        handlers_1.PaymentHandler.checkForPendingPayment(onIncompletePaymentFound);
        this.consentedScopes = user.credentials.scopes;
        return { user, accessToken: this.api.accessToken };
    }
    /**
     * Create a payment
     *
     * @param paymentData - The information about the payment
     * @param callbacks - Callback functions for the payment process
     * @returns the payment handler for the created payment
     */
    createPayment(paymentData, callbacks) {
        this.checkInitialized();
        if (this.getPiHostApp() === 'pi-net') {
            throw new Error('Method unsupported in PiNet.');
        }
        if (!this.consentedScopes.includes('payments')) {
            throw new Error('Cannot create a payment without "payments" scope');
        }
        return new handlers_1.PaymentHandler(paymentData, callbacks, this.onIncompletePaymentFound);
    }
    /**
     * Open the share dialog
     *
     * @param title - The title of the message
     * @param sharingMessage - The message to share
     */
    async openShareDialog(title, sharingMessage) {
        this.checkInitialized();
        const openShareDialogResult = await handlers_1.MessageHandler.sendSDKMessage({
            type: message_types_1.MessageType.OPEN_SHARE_DIALOG_ACTION,
            payload: { title, sharingMessage },
        });
        if (openShareDialogResult?.payload.pinet_unsupported) {
            throw new Error('Method unsupported in PiNet.');
        }
    }
    /**
     * Open a conversation
     *
     * @param conversationId - The conversation id
     */
    async openConversation(conversationId) {
        this.checkInitialized();
        const openAppConversationResult = await handlers_1.MessageHandler.sendSDKMessage({
            type: message_types_1.MessageType.OPEN_APP_CONVERSATION_WITH_ID,
            payload: { conversationId },
        });
        if (openAppConversationResult?.payload.pinet_unsupported) {
            throw new Error('Method unsupported in PiNet.');
        }
    }
    /**
     * Get the list of the native feature available in client platform
     *
     * @returns the list of native features available in client platform
     */
    async nativeFeaturesList() {
        this.checkInitialized();
        const nativeFeaturesList = await handlers_1.MessageHandler.sendSDKMessage({ type: message_types_1.MessageType.CHECK_NATIVE_FEATURES });
        if (!nativeFeaturesList) {
            return [];
        }
        if (nativeFeaturesList.payload.pinet_unsupported) {
            throw new Error('Method unsupported in PiNet.');
        }
        return nativeFeaturesList.payload.features;
    }
    /**
     * Copy given text to user clipboard
     *
     * @param text - The text to copy
     */
    async copyText(text) {
        this.checkInitialized();
        const copyTextResult = await handlers_1.MessageHandler.sendSDKMessage({
            type: message_types_1.MessageType.COPY_TEXT_FROM_TPA,
            payload: { text },
        });
        if (copyTextResult?.payload.pinet_unsupported) {
            throw new Error('Method unsupported in PiNet.');
        }
    }
    /**
     * Request for a permission to the user
     *
     * @param permission - The permission to request
     * @returns Whether or not the requested permission has been granted
     */
    async requestPermission(permission) {
        this.checkInitialized();
        const requestPermissionResponse = await handlers_1.MessageHandler.sendSDKMessage({
            type: message_types_1.MessageType.REQUEST_NATIVE_PERMISSION,
            payload: { permission },
        });
        if (requestPermissionResponse?.payload.pinet_unsupported) {
            throw new Error('Method unsupported in PiNet.');
        }
        return !!requestPermissionResponse?.payload.granted;
    }
    /**
     * Open the given url in system browser
     *
     * @param url - The url to open
     */
    async openUrlInSystemBrowser(url) {
        this.checkInitialized();
        const openUrlInSystemBrowserResponse = await handlers_1.MessageHandler.sendSDKMessage({
            type: message_types_1.MessageType.OPEN_URL_IN_SYSTEM_BROWSER,
            payload: { url },
        });
        if (!openUrlInSystemBrowserResponse) {
            throw new Error('Unexpected error');
        }
        if (openUrlInSystemBrowserResponse.payload.success) {
            return;
        }
        if (openUrlInSystemBrowserResponse.payload.pinet_unsupported) {
            throw new Error('Method unsupported in PiNet.');
        }
        throw new Error(openUrlInSystemBrowserResponse.payload.message);
    }
    /**
     * Get the Pi Network hosting app behind the current app
     *
     * @returns The Pi Network hosting app
     */
    getPiHostApp() {
        const { referrer } = document;
        const { userAgent } = window.navigator;
        if (referrer.startsWith('https://app-cdn.minepi.com')) {
            return userAgent.includes('PiBrowser') ? 'pi-browser' : 'pi-app';
        }
        if (util_1.PINET_REGEX.test(referrer)) {
            return 'pi-net';
        }
    }
    /**
     * Initialize the usage tracking system
     */
    initTracking() {
        this.api.post(api_typing_1.trackUsage, {});
        let lastTrackingRequestTimestamp = Date.now();
        const events = ['click', 'scroll', 'mousemove', 'touchend', 'change'];
        for (const event of events) {
            /* eslint-disable-next-line @typescript-eslint/no-loop-func */
            document.addEventListener(event, () => {
                if (Date.now() - lastTrackingRequestTimestamp < 15_000) {
                    return;
                }
                this.api.post(api_typing_1.trackUsage, {});
                lastTrackingRequestTimestamp = Date.now();
            });
        }
    }
    /**
     * Check if the SDK client has been initialized before use
     */
    checkInitialized() {
        if (this.initialized) {
            return;
        }
        throw new Error('Pi Network SDK was not initialized. Call init() before any other method.');
    }
}
exports.PiClient = PiClient;
