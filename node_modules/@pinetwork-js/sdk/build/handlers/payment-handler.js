"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PaymentHandler = void 0;
const api_typing_1 = require("@pinetwork-js/api-typing");
const util_1 = require("../util");
const message_types_1 = require("../message-types");
const message_handler_1 = require("./message-handler");
const request_handler_1 = require("./request-handler");
/**
 * Handler for payments
 */
class PaymentHandler {
    paymentData;
    callbacks;
    onIncompletePaymentFound;
    /**
     * Number of retries allowed
     */
    retryCounter = 5;
    constructor(
    /**
     * Information about the payment
     */
    paymentData, 
    /**
     * Callback functions for the payment process
     */
    callbacks, 
    /**
     * Callback function triggered if an incomplete payment is found
     */
    onIncompletePaymentFound) {
        this.paymentData = paymentData;
        this.callbacks = callbacks;
        this.onIncompletePaymentFound = onIncompletePaymentFound;
        this.runPaymentFlow();
    }
    /**
     * Check if there is a pending payment
     *
     * @param onIncompletePaymentFound - Callback function triggered if an incomplete payment is found
     */
    static async checkForPendingPayment(onIncompletePaymentFound) {
        const incompletePayment = await request_handler_1.RequestHandler.getInstance().get(api_typing_1.getIncompleteClientPayment).catch();
        if (!incompletePayment?.exists || incompletePayment.payment.status.cancelled) {
            return;
        }
        onIncompletePaymentFound(incompletePayment.payment);
    }
    async retryableCallback(retryCallback, paymentStatus) {
        retryCallback();
        await (0, util_1.sleep)(10_000);
        const decideCallbackRetrial = await message_handler_1.MessageHandler.sendSDKMessage({
            type: message_types_1.MessageType.DECIDE_CALLBACK_RETRIAL,
            payload: { targetStatus: paymentStatus },
        });
        if (decideCallbackRetrial?.payload.retry && this.retryCounter > 0) {
            this.retryCounter--;
            return this.retryableCallback(retryCallback, paymentStatus);
        }
        this.retryCounter = 5;
    }
    /**
     * Run the payment flow
     */
    async runPaymentFlow() {
        const paymentMessage = await message_handler_1.MessageHandler.sendSDKMessage({
            type: message_types_1.MessageType.PREPARE_PAYMENT_FLOW,
        }).catch((error) => this.callbacks.onError(error));
        if (!paymentMessage) {
            return;
        }
        if (paymentMessage.payload.pending) {
            const { pendingPayment } = paymentMessage.payload;
            message_handler_1.MessageHandler.sendSDKMessage({
                type: message_types_1.MessageType.SHOW_PRE_PAYMENT_ERROR,
                payload: { paymentError: 'pending_check_failed' },
            });
            this.callbacks.onError(new Error('A pending payment needs to be handled.'), pendingPayment);
            this.onIncompletePaymentFound(pendingPayment);
            return;
        }
        const payment = await request_handler_1.RequestHandler.getInstance()
            .post(api_typing_1.createUserToAppPayment, this.paymentData)
            .catch((requestError) => {
            message_handler_1.MessageHandler.sendSDKMessage({
                type: message_types_1.MessageType.SHOW_PRE_PAYMENT_ERROR,
                payload: { paymentError: requestError.response.data.error },
            });
            this.callbacks.onError(requestError);
        });
        if (!payment) {
            return;
        }
        const paymentId = payment.identifier;
        message_handler_1.MessageHandler.sendSDKMessage({ type: message_types_1.MessageType.START_PAYMENT_FLOW, payload: { paymentId } });
        this.retryableCallback(() => {
            this.callbacks.onReadyForServerApproval(paymentId);
        }, 'developerApproved');
        const approvedPaymentMessage = await message_handler_1.MessageHandler.sendSDKMessage({
            type: message_types_1.MessageType.WAIT_FOR_TRANSACTION,
        }).catch((error) => this.callbacks.onError(error));
        if (!approvedPaymentMessage) {
            return;
        }
        if (approvedPaymentMessage.payload.cancelled) {
            this.callbacks.onCancel(approvedPaymentMessage.payload.paymentId);
            return;
        }
        this.retryableCallback(() => {
            this.callbacks.onReadyForServerCompletion(approvedPaymentMessage.payload.paymentId, approvedPaymentMessage.payload.txid);
        }, 'developerCompleted');
    }
}
exports.PaymentHandler = PaymentHandler;
