"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MessageHandler = void 0;
const util_1 = require("../util");
/**
 * Handler for messages
 */
class MessageHandler {
    /**
     * Last emitted message id
     */
    static lastEmittedId = 0;
    /**
     * A list of emitted promises
     */
    static emittedPromises = {};
    /**
     * Whether the application is executed in the Pi Network sandbox
     */
    static sandboxMode = false;
    /**
     * @returns the host platform URL of the application
     */
    static getHostPlatformURL() {
        if (MessageHandler.sandboxMode) {
            return 'https://sandbox.minepi.com';
        }
        const [, pinetApp] = document.referrer.match(util_1.PINET_REGEX) ?? [];
        return pinetApp ? `https://${pinetApp}.pinet.com` : 'https://app-cdn.minepi.com';
    }
    /**
     * @param sandboxMode - True if in sandbox, false otherwhise
     */
    static setSandboxMode(sandboxMode) {
        MessageHandler.sandboxMode = sandboxMode;
    }
    /**
     * Send a message to the Pi Network hosting page
     *
     * @param message - The message to send
     * @returns the message returned by the Pi Network hosting page
     */
    static sendSDKMessage(message) {
        const id = MessageHandler.lastEmittedId++;
        const messageToSend = { id, ...message };
        const hostPlatformURL = MessageHandler.getHostPlatformURL();
        if (util_1.DEBUG) {
            console.log(`Sending message to app platform (target origin: ${hostPlatformURL}):`, messageToSend);
        }
        window.parent.postMessage(JSON.stringify(messageToSend), hostPlatformURL);
        return new Promise((resolve, reject) => {
            MessageHandler.emittedPromises[id] = { resolve, reject };
            setTimeout(() => {
                if (util_1.DEBUG) {
                    console.error(`Messaging promise with id ${id} timed out after 120000ms.`);
                }
                reject();
            }, 120_000);
        });
    }
    /**
     * Handle message events
     *
     * @param event - The message event received
     */
    static handleIncomingMessage(event) {
        let parsedData = {};
        try {
            if (typeof event.data !== 'string') {
                if (util_1.DEBUG) {
                    console.log('Received message with non-string data:', event.data);
                }
                return;
            }
            parsedData = JSON.parse(event.data);
            if (!('id' in parsedData) || parsedData.id === undefined) {
                throw new Error('No id found in message response');
            }
            if (util_1.DEBUG) {
                console.log(`Received response for message id ${parsedData.id}:`, parsedData);
            }
            if (!(parsedData.id in MessageHandler.emittedPromises)) {
                throw new Error(`No emitted promise found for native messaging response id ${parsedData.id}`);
            }
            // @ts-expect-error parsedData.id is not undefined, but it says it is
            MessageHandler.emittedPromises[parsedData.id].resolve(parsedData);
            delete MessageHandler.emittedPromises[parsedData.id];
        }
        catch (error) {
            if (util_1.DEBUG) {
                console.error(`Native messaging: error when handling ${parsedData.id === undefined
                    ? `incoming message (possible response?)`
                    : `response for message id ${parsedData.id}`}. Error is logged below.`);
                console.error(error);
                console.error(event.data);
            }
            if (parsedData.id && parsedData.id in MessageHandler.emittedPromises) {
                MessageHandler.emittedPromises[parsedData.id].reject(error);
            }
        }
    }
}
exports.MessageHandler = MessageHandler;
if (typeof window !== 'undefined') {
    window.addEventListener('message', (message) => MessageHandler.handleIncomingMessage(message));
}
